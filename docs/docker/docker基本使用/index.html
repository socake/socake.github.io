<!doctype html><html lang=zh-CN dir=ltr class=scroll-smooth data-default-appearance=dark data-auto-appearance=true><head><meta charset=utf-8><meta http-equiv=content-language content="zh-CN"><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=theme-color><title>Docker基本使用 &#183; Startlight</title><meta name=title content="Docker基本使用 &#183; Startlight"><meta name=keywords content="Docker,"><link rel=canonical href=https://your_domain.com/docs/docker/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/><meta name=author content="Wenzhuo Huang"><link href=17691281867@163.com rel=me><meta property="og:url" content="https://your_domain.com/docs/docker/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"><meta property="og:site_name" content="Startlight"><meta property="og:title" content="Docker基本使用"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2025-12-03T22:26:23+08:00"><meta property="article:modified_time" content="2025-12-03T22:26:23+08:00"><meta property="article:tag" content="Docker"><meta property="og:image" content="https://your_domain.com/docs/docker/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/featured.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://your_domain.com/docs/docker/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/featured.jpg"><meta name=twitter:title content="Docker基本使用"><link type=text/css rel=stylesheet href=/css/main.bundle.min.0975a8c7c266a0697f94839b45e1574c449de253527d44ed516d5c5c3c820c9389d7d86576faae12267b129f8749ecbf7581cddb636aba7690aa633b95aaa87d.css integrity="sha512-CXWox8JmoGl/lIObReFXTESd4lNSfUTtUW1cXDyCDJOJ19hldvquEiZ7Ep+HSey/dYHN22NqunaQqmM7laqofQ=="><script type=text/javascript src=/js/appearance.min.6f41174b3a05b680820fe08cadbfa5fb7a7ca347b76a0955cdc68b9d8aca1ce24f0547e138cea33bcc7904d551a90afcb1cc7f2d9fe8557075d501419046c08c.js integrity="sha512-b0EXSzoFtoCCD+CMrb+l+3p8o0e3aglVzcaLnYrKHOJPBUfhOM6jO8x5BNVRqQr8scx/LZ/oVXB11QFBkEbAjA=="></script><script src=/lib/zoom/zoom.min.umd.a527109b68c082a70f3697716dd72a9d5aa8b545cf800cecbbc7399f2ca6f6e0ce3e431f2062b48bbfa47c9ea42822714060bef309be073f49b9c0e30d318d7b.js integrity="sha512-pScQm2jAgqcPNpdxbdcqnVqotUXPgAzsu8c5nyym9uDOPkMfIGK0i7+kfJ6kKCJxQGC+8wm+Bz9JucDjDTGNew=="></script><script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.9df4fc14d50efcc9aa4cfc2b6f348e365f421f5ad491278f8f48c0360cf2f93f08882fda6da162d7ace8e5add57c2df4ac46bd3861306b1d4c452cd31f448d64.js integrity="sha512-nfT8FNUO/MmqTPwrbzSONl9CH1rUkSePj0jANgzy+T8IiC/abaFi16zo5a3VfC30rEa9OGEwax1MRSzTH0SNZA==" data-copy=复制 data-copied=已复制></script><script src=/lib/jquery/jquery.slim.min.b0dca576e87d7eaa5850ae4e61759c065786cdb6489d68fcc82240539eebd5da522bdb4fda085ffd245808c8fe2acb2516408eb774ef26b5f6015fc6737c0ea8.js integrity="sha512-sNylduh9fqpYUK5OYXWcBleGzbZInWj8yCJAU57r1dpSK9tP2ghf/SRYCMj+KsslFkCOt3TvJrX2AV/Gc3wOqA=="></script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><script type=application/ld+json>[{"@context":"https://schema.org","@type":"Article","articleSection":"Docs","name":"Docker基本使用","headline":"Docker基本使用","inLanguage":"zh-CN","url":"https://your_domain.com/docs/docker/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","author":{"@type":"Person","name":"Wenzhuo Huang"},"copyrightYear":"2025","dateCreated":"2025-12-03T22:26:23\u002b08:00","datePublished":"2025-12-03T22:26:23\u002b08:00","dateModified":"2025-12-03T22:26:23\u002b08:00","keywords":["Docker"],"mainEntityOfPage":"true","wordCount":"1775"}]</script></head><body class="flex flex-col h-screen m-auto leading-7 max-w-7xl px-6 sm:px-14 md:px-24 lg:px-32 text-lg bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="font-bold text-primary-600 pe-2 dark:text-primary-400">&darr;</span>
跳过正文</a></div><div class=min-h-[148px]></div><div class="fixed inset-x-0 z-100"><div id=menu-blur class="absolute opacity-0 inset-x-0 top-0 h-full single_hero_background nozoom backdrop-blur-2xl shadow-2xl"></div><div class="relative m-auto leading-7 max-w-7xl px-6 sm:px-14 md:px-24 lg:px-32"><div class="main-menu flex items-center justify-between py-6 md:justify-start gap-x-3 pt-[2px] pr-2 md:pr-4 pb-[3px] pl-0"><div><a href=/ class=flex><span class=sr-only>Startlight</span>
<img src=/img/emoji.png width=80 height=80 class="logo max-h-[5rem] max-w-[5rem] object-scale-down object-left nozoom" alt></a></div><div class="flex flex-1 items-center justify-between"><nav class="flex space-x-3"><a href=/ class="text-base font-medium">Startlight</a></nav><nav class="hidden md:flex items-center gap-x-5 md:ml-12 h-12"><a href=/posts/ class="flex items-center hover:text-primary-600 dark:hover:text-primary-400" aria-label=博客 title=Posts><p class="text-base font-medium">博客</p></a><a href=/books/ class="flex items-center hover:text-primary-600 dark:hover:text-primary-400" aria-label=书籍 title=我的数字书架><p class="text-base font-medium">书籍</p></a><a href class="flex items-center hover:text-primary-600 dark:hover:text-primary-400" aria-label=编程 title><p class="text-base font-medium">编程</p></a><a href=https://github.com/socake target=_blank class="flex items-center hover:text-primary-600 dark:hover:text-primary-400" aria-label=GitHub title><span class=mr-1><span class="relative block icon"><svg viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span></span><p class="text-base font-medium">GitHub</p></a><div><div class="cursor-pointer flex items-center nested-menu"><a aria-label=文档 class="text-base font-medium hover:text-primary-600 dark:hover:text-primary-400" title><p>文档</p></a><span><span class="relative block icon"><svg viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path fill-rule="evenodd" d="M5.23 7.21a.75.75.0 011.06.02L10 11.168l3.71-3.938a.75.75.0 111.08 1.04l-4.25 4.5a.75.75.0 01-1.08.0l-4.25-4.5a.75.75.0 01.02-1.06z" clip-rule="evenodd"/></svg></span></span></div><div class="absolute menuhide"><div class="pt-2 p-5 mt-2 rounded-xl backdrop-blur shadow-2xl"><div class="flex flex-col space-y-3"><a href=/categories/docker/ aria-label=docker class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"><p class="text-sm font-sm" title=Docker>docker</p></a></div></div></div></div><div><div class="cursor-pointer flex items-center nested-menu"><a aria-label=资源 class="text-base font-medium hover:text-primary-600 dark:hover:text-primary-400" title><p>资源</p></a><span><span class="relative block icon"><svg viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path fill-rule="evenodd" d="M5.23 7.21a.75.75.0 011.06.02L10 11.168l3.71-3.938a.75.75.0 111.08 1.04l-4.25 4.5a.75.75.0 01-1.08.0l-4.25-4.5a.75.75.0 01.02-1.06z" clip-rule="evenodd"/></svg></span></span></div><div class="absolute menuhide"><div class="pt-2 p-5 mt-2 rounded-xl backdrop-blur shadow-2xl"><div class="flex flex-col space-y-3"><a href=/tags/%E6%A8%A1%E6%9D%BF/ aria-label=模板 class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"><p class="text-sm font-sm" title=模板>模板</p></a><a href aria-label=网站 class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"><p class="text-sm font-sm" title>网站</p></a></div></div></div></div><button id=search-button aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title="搜索 (/)">
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button><div class="flex items-center"><button id=appearance-switcher aria-label="Dark mode switcher" type=button class="text-base hover:text-primary-600 dark:hover:text-primary-400"><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></nav><div class="flex md:hidden items-center gap-x-5 md:ml-12 h-12"><span></span>
<button id=search-button-mobile aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title="搜索 (/)">
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span></button>
<button id=appearance-switcher-mobile aria-label="Dark mode switcher" type=button class="text-base hover:text-primary-600 dark:hover:text-primary-400 me-1"><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></div><div class="-my-2 md:hidden"><div id=menu-button class=block><div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416c17.7.0 32 14.33 32 32 0 17.7-14.3 32-32 32H32C14.33 128 0 113.7.0 96zM0 256c0-17.7 14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32H32c-17.67.0-32-14.3-32-32zM416 448H32c-17.67.0-32-14.3-32-32s14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32z"/></svg></span></div><div id=menu-wrapper class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50 pt-[5px]"><ul class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none text-end max-w-7xl"><li id=menu-close-button><span class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></span></li><li class=mt-1><a href=/posts/ class="flex items-center hover:text-primary-600 dark:hover:text-primary-400" aria-label=博客 title=Posts><p class="text-bg font-bg">博客</p></a></li><li class=mt-1><a href=/books/ class="flex items-center hover:text-primary-600 dark:hover:text-primary-400" aria-label=书籍 title=我的数字书架><p class="text-bg font-bg">书籍</p></a></li><li class=mt-1><a href class="flex items-center hover:text-primary-600 dark:hover:text-primary-400" aria-label=编程 title><p class="text-bg font-bg">编程</p></a></li><li class=mt-1><a href=https://github.com/socake target=_blank class="flex items-center hover:text-primary-600 dark:hover:text-primary-400" aria-label=GitHub title><div class=mr-2><span class="relative block icon"><svg viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span></div><p class="text-bg font-bg">GitHub</p></a></li><li class=mt-1><a href aria-label=文档 class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title>文档</p><span><span class="relative block icon"><svg viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path fill-rule="evenodd" d="M5.23 7.21a.75.75.0 011.06.02L10 11.168l3.71-3.938a.75.75.0 111.08 1.04l-4.25 4.5a.75.75.0 01-1.08.0l-4.25-4.5a.75.75.0 01.02-1.06z" clip-rule="evenodd"/></svg></span></span></a></li><li class=mt-1><a href=/categories/docker/ aria-label=docker class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"><p class="text-sm font-small" title=Docker>docker</p></a></li><li class=mb-2></li><li class=mt-1><a href aria-label=资源 class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title>资源</p><span><span class="relative block icon"><svg viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path fill-rule="evenodd" d="M5.23 7.21a.75.75.0 011.06.02L10 11.168l3.71-3.938a.75.75.0 111.08 1.04l-4.25 4.5a.75.75.0 01-1.08.0l-4.25-4.5a.75.75.0 01.02-1.06z" clip-rule="evenodd"/></svg></span></span></a></li><li class=mt-1><a href=/tags/%E6%A8%A1%E6%9D%BF/ aria-label=模板 class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"><p class="text-sm font-small" title=模板>模板</p></a></li><li class=mt-1><a href aria-label=网站 class="flex items-center hover:text-primary-600 dark:hover:text-primary-400"><p class="text-sm font-small" title>网站</p></a></li><li class=mb-2></li></ul></div></div></div></div></div></div><script type=text/javascript src=/js/background-blur.min.00a57c73ea12f2cab2980c3c3d649e89f6d82f190f74bbe2b67f2f5e39ab7d032ece47086400ca05396758aace13299da49aca43ea643d2625e62c506267a169.js integrity="sha512-AKV8c+oS8sqymAw8PWSeifbYLxkPdLvitn8vXjmrfQMuzkcIZADKBTlnWKrOEymdpJrKQ+pkPSYl5ixQYmehaQ==" data-blur-id=menu-blur></script><div class="relative flex flex-col grow"><main id=main-content class=grow><article><div id=hero class="h-[150px] md:h-[200px]"></div><div class="fixed inset-x-0 top-0 h-[800px] single_hero_background nozoom"><img id=background-image src=/docs/docker/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/featured_hu_cdfb79a85bda34be.jpg alt=Docker基本使用 loading=eager decoding=async fetchpriority=high class="absolute inset-0 w-full h-full object-cover"><div class="absolute inset-0 bg-gradient-to-t from-neutral dark:from-neutral-800 to-transparent mix-blend-normal"></div><div class="absolute inset-0 opacity-60 bg-gradient-to-t from-neutral dark:from-neutral-800 to-neutral-100 dark:to-neutral-800 mix-blend-normal"></div></div><div id=background-blur class="fixed opacity-0 inset-x-0 top-0 h-full single_hero_background nozoom backdrop-blur-2xl"></div><script type=text/javascript src=/js/background-blur.min.00a57c73ea12f2cab2980c3c3d649e89f6d82f190f74bbe2b67f2f5e39ab7d032ece47086400ca05396758aace13299da49aca43ea643d2625e62c506267a169.js integrity="sha512-AKV8c+oS8sqymAw8PWSeifbYLxkPdLvitn8vXjmrfQMuzkcIZADKBTlnWKrOEymdpJrKQ+pkPSYl5ixQYmehaQ==" data-blur-id=background-blur data-image-id=background-image data-image-url=/docs/docker/docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/featured_hu_cdfb79a85bda34be.jpg></script><header id=single_header class="mt-5 max-w-prose"><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">Docker基本使用</h1><div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime=2025-12-03T22:26:23+08:00>2025-12-03 22:26</time><span class="px-2 text-primary-500">&#183;</span><span>1775 字</span><span class="px-2 text-primary-500">&#183;</span><span title=预计阅读>9 分钟</span></div></div></header><section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row"><div class="order-first lg:ml-auto px-0 lg:order-last lg:ps-8 lg:max-w-2xs"><div class="toc ps-5 print:hidden lg:sticky lg:top-[140px]"><details open id=TOCView class="toc-right mt-0 overflow-y-auto overscroll-contain scrollbar-thin scrollbar-track-neutral-200 scrollbar-thumb-neutral-400 dark:scrollbar-track-neutral-800 dark:scrollbar-thumb-neutral-600 rounded-lg -ms-5 ps-5 pe-2 hidden lg:block"><summary class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 -ms-5 ps-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">目录</summary><div class="min-w-[220px] py-2 border-dotted border-s-1 -ms-5 ps-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#1-查看查找镜像>1. <strong>查看、查找镜像</strong></a></li><li><a href=#2-拉取镜像pull>2. <strong>拉取镜像（Pull）</strong></a></li><li><a href=#3-构建镜像build>3. <strong>构建镜像（Build）</strong></a></li><li><a href=#4-镜像标签tagging>4. <strong>镜像标签（Tagging）</strong></a></li><li><a href=#5-推送镜像push>5. <strong>推送镜像（Push）</strong></a></li><li><a href=#6-删除镜像remove>6. <strong>删除镜像（Remove）</strong></a></li><li><a href=#7-清理未使用的镜像>7. <strong>清理未使用的镜像</strong></a></li><li><a href=#8-查看镜像历史>8. <strong>查看镜像历史</strong></a></li><li><a href=#9-镜像仓库>9. <strong>镜像仓库</strong></a></li><li><a href=#10-导入及导出镜像>10. 导入及导出镜像</a><ul><li><ul><li><a href=#导出镜像为tar包>导出镜像为tar包</a></li><li><a href=#导入tar包为镜像>导入tar包为镜像</a></li></ul></li></ul></li><li><a href=#11-备份镜像>11. 备份镜像</a></li><li><a href=#常见镜像命令总结><strong>常见镜像命令总结</strong></a></li></ul><ul><li><a href=#1-容器概述>1. 容器概述</a><ul><li><a href=#11-什么是容器>1.1 什么是容器</a></li><li><a href=#12-容器与镜像的关系>1.2 容器与镜像的关系</a></li></ul></li><li><a href=#2-容器的使用>2. 容器的使用</a><ul><li><a href=#21-启动容器run>2.1 <strong>启动容器（Run）</strong></a></li><li><a href=#22-查看容器列表>2.2 <strong>查看容器列表</strong></a></li><li><a href=#23-进入退出容器>2.3 <strong>进入、退出容器</strong></a><ul><li><a href=#进入容器>进入容器</a></li><li><a href=#退出容器>退出容器</a></li><li><a href=#容器内外的文件复制>容器内外的文件复制</a></li></ul></li><li><a href=#24--停止容器>2.4 <strong>停止容器</strong></a></li><li><a href=#25-重启容器>2.5 <strong>重启容器</strong></a></li><li><a href=#26-删除容器>2.6 <strong>删除容器</strong></a></li><li><a href=#27--查看容器日志>2.7 <strong>查看容器日志</strong></a></li><li><a href=#28-查看容器的详细情况>2.8 <strong>查看容器的详细情况</strong></a></li><li><a href=#29--管理容器网络>2.9 <strong>管理容器网络</strong></a></li><li><a href=#210-容器与卷volumes>2.10 <strong>容器与卷（Volumes）</strong></a><ul><li><a href=#使用卷>使用卷</a></li><li><a href=#容器数据卷继承>容器数据卷继承</a></li></ul></li><li><a href=#211-容器的备份>2.11 容器的备份</a></li><li><a href=#212常见容器命令总结>2.12常见容器命令总结</a></li></ul></li></ul><ul><li><a href=#1-bridge>1. Bridge</a><ul><li><a href=#默认bridge>默认Bridge</a></li><li><a href=#自定义bridge>自定义Bridge</a></li></ul></li><li><a href=#2-container>2. Container</a></li><li><a href=#3-host>3. Host</a></li><li><a href=#4none>4.None</a></li><li><a href=#5-overlay>5. Overlay</a><ul><li><a href=#覆盖网络的创建>覆盖网络的创建</a></li><li><a href=#vxlan>VXLAN</a><ul><li><a href=#vxaln介绍>Vxaln介绍</a></li><li><a href=#vxlan在多主机容器通信的应用>Vxlan在多主机容器通信的应用</a></li><li><a href=#容器通信过程>容器通信过程</a></li><li><a href=#覆盖网络实现三层路由>覆盖网络实现三层路由</a></li></ul></li></ul></li><li><a href=#6-macvlan>6. Macvlan</a></li></ul></nav></div></details><details class="toc-inside mt-0 overflow-hidden rounded-lg -ms-5 ps-5 lg:hidden"><summary class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 -ms-5 ps-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">目录</summary><div class="py-2 border-dotted border-neutral-300 border-s-1 -ms-5 ps-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#1-查看查找镜像>1. <strong>查看、查找镜像</strong></a></li><li><a href=#2-拉取镜像pull>2. <strong>拉取镜像（Pull）</strong></a></li><li><a href=#3-构建镜像build>3. <strong>构建镜像（Build）</strong></a></li><li><a href=#4-镜像标签tagging>4. <strong>镜像标签（Tagging）</strong></a></li><li><a href=#5-推送镜像push>5. <strong>推送镜像（Push）</strong></a></li><li><a href=#6-删除镜像remove>6. <strong>删除镜像（Remove）</strong></a></li><li><a href=#7-清理未使用的镜像>7. <strong>清理未使用的镜像</strong></a></li><li><a href=#8-查看镜像历史>8. <strong>查看镜像历史</strong></a></li><li><a href=#9-镜像仓库>9. <strong>镜像仓库</strong></a></li><li><a href=#10-导入及导出镜像>10. 导入及导出镜像</a><ul><li><ul><li><a href=#导出镜像为tar包>导出镜像为tar包</a></li><li><a href=#导入tar包为镜像>导入tar包为镜像</a></li></ul></li></ul></li><li><a href=#11-备份镜像>11. 备份镜像</a></li><li><a href=#常见镜像命令总结><strong>常见镜像命令总结</strong></a></li></ul><ul><li><a href=#1-容器概述>1. 容器概述</a><ul><li><a href=#11-什么是容器>1.1 什么是容器</a></li><li><a href=#12-容器与镜像的关系>1.2 容器与镜像的关系</a></li></ul></li><li><a href=#2-容器的使用>2. 容器的使用</a><ul><li><a href=#21-启动容器run>2.1 <strong>启动容器（Run）</strong></a></li><li><a href=#22-查看容器列表>2.2 <strong>查看容器列表</strong></a></li><li><a href=#23-进入退出容器>2.3 <strong>进入、退出容器</strong></a><ul><li><a href=#进入容器>进入容器</a></li><li><a href=#退出容器>退出容器</a></li><li><a href=#容器内外的文件复制>容器内外的文件复制</a></li></ul></li><li><a href=#24--停止容器>2.4 <strong>停止容器</strong></a></li><li><a href=#25-重启容器>2.5 <strong>重启容器</strong></a></li><li><a href=#26-删除容器>2.6 <strong>删除容器</strong></a></li><li><a href=#27--查看容器日志>2.7 <strong>查看容器日志</strong></a></li><li><a href=#28-查看容器的详细情况>2.8 <strong>查看容器的详细情况</strong></a></li><li><a href=#29--管理容器网络>2.9 <strong>管理容器网络</strong></a></li><li><a href=#210-容器与卷volumes>2.10 <strong>容器与卷（Volumes）</strong></a><ul><li><a href=#使用卷>使用卷</a></li><li><a href=#容器数据卷继承>容器数据卷继承</a></li></ul></li><li><a href=#211-容器的备份>2.11 容器的备份</a></li><li><a href=#212常见容器命令总结>2.12常见容器命令总结</a></li></ul></li></ul><ul><li><a href=#1-bridge>1. Bridge</a><ul><li><a href=#默认bridge>默认Bridge</a></li><li><a href=#自定义bridge>自定义Bridge</a></li></ul></li><li><a href=#2-container>2. Container</a></li><li><a href=#3-host>3. Host</a></li><li><a href=#4none>4.None</a></li><li><a href=#5-overlay>5. Overlay</a><ul><li><a href=#覆盖网络的创建>覆盖网络的创建</a></li><li><a href=#vxlan>VXLAN</a><ul><li><a href=#vxaln介绍>Vxaln介绍</a></li><li><a href=#vxlan在多主机容器通信的应用>Vxlan在多主机容器通信的应用</a></li><li><a href=#容器通信过程>容器通信过程</a></li><li><a href=#覆盖网络实现三层路由>覆盖网络实现三层路由</a></li></ul></li></ul></li><li><a href=#6-macvlan>6. Macvlan</a></li></ul></nav></div></details></div></div><div class="min-w-0 min-h-0 max-w-fit"><div class="article-content max-w-prose mb-20"><h1 class="relative group">二、Docker镜像管理<div id=二docker镜像管理 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e4%ba%8cdocker%e9%95%9c%e5%83%8f%e7%ae%a1%e7%90%86 aria-label=锚点>#</a></span></h1><h2 class="relative group">1. <strong>查看、查找镜像</strong><div id=1-查看查找镜像 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#1-%e6%9f%a5%e7%9c%8b%e6%9f%a5%e6%89%be%e9%95%9c%e5%83%8f aria-label=锚点>#</a></span></h2><p>使用 <code>docker images</code> 命令可以列出本地系统上所有的 Docker 镜像，包括镜像的仓库名称、标签、镜像 ID、创建时间和大小等信息。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker images
</span></span></code></pre></div><p>输出示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>REPOSITORY          TAG       IMAGE ID          CREATED         SIZE
</span></span><span class=line><span class=cl>nginx                  latest      7f7b05e59d6a   <span class=m>2</span> weeks ago     142MB
</span></span><span class=line><span class=cl>ubuntu                 20.04     8d5c9eec5b6a   <span class=m>3</span> weeks ago     64.2MB
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker search <span class=o>[</span>OPTIONS<span class=o>]</span> 镜像名字
</span></span><span class=line><span class=cl>参数：
</span></span><span class=line><span class=cl>--limit nu   <span class=c1>#只输出查到的前nu条记录</span>
</span></span><span class=line><span class=cl>docker search redis --limit <span class=m>3</span>    <span class=c1># 放在镜像名称前面后面均可</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>字段解析：
</span></span><span class=line><span class=cl>NAME：镜像名称
</span></span><span class=line><span class=cl>DISCRIPTION：镜像说明
</span></span><span class=line><span class=cl>STARTS：点赞数
</span></span><span class=line><span class=cl>OFFICAL：是否是官方认可的
</span></span><span class=line><span class=cl>AUTOMATED：是否自动构建 
</span></span></code></pre></div><h2 class="relative group">2. <strong>拉取镜像（Pull）</strong><div id=2-拉取镜像pull class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#2-%e6%8b%89%e5%8f%96%e9%95%9c%e5%83%8fpull aria-label=锚点>#</a></span></h2><p>从 Docker Hub 或其他镜像仓库拉取镜像到本地。使用 <code>docker pull</code> 命令来下载镜像。默认从 Docker Hub 拉取镜像。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker pull &lt;image_name&gt;:&lt;tag&gt;
</span></span></code></pre></div><p>例如，拉取最新的 Ubuntu 镜像：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker pull ubuntu:20.04
</span></span></code></pre></div><p>如果没有指定标签，默认拉取 <code>latest</code> 标签的镜像。</p><p><em>镜像难以拉取，则需要在 /etc/daocker/daemon.json 配置加速器</em></p><h2 class="relative group">3. <strong>构建镜像（Build）</strong><div id=3-构建镜像build class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#3-%e6%9e%84%e5%bb%ba%e9%95%9c%e5%83%8fbuild aria-label=锚点>#</a></span></h2><p>使用 <code>docker build</code> 命令根据 Dockerfile 构建镜像。Dockerfile 是一个包含镜像构建步骤的文本文件，它定义了如何从基础镜像创建新的镜像。</p><p><em>Dockerfile有多个重要指令，后面会说明</em></p><p>构建镜像的命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker build -t &lt;image_name&gt;:&lt;tag&gt; &lt;path_to_dockerfile&gt;
</span></span></code></pre></div><p>例如，在当前目录构建一个名为 <code>my-app</code> 的镜像：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker build -t my-app:latest .
</span></span></code></pre></div><h2 class="relative group">4. <strong>镜像标签（Tagging）</strong><div id=4-镜像标签tagging class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#4-%e9%95%9c%e5%83%8f%e6%a0%87%e7%ad%betagging aria-label=锚点>#</a></span></h2><p>镜像标签用于标识镜像的不同版本。每个镜像默认有一个标签 <code>latest</code>，但你可以使用 <code>docker tag</code> 命令为镜像打上新的标签。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker tag &lt;image_id&gt; &lt;new_image_name&gt;:&lt;new_tag&gt;
</span></span></code></pre></div><p>例如，为 <code>my-app</code> 镜像打上版本标签：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker tag my-app:latest my-app:v1.0
</span></span></code></pre></div><h2 class="relative group">5. <strong>推送镜像（Push）</strong><div id=5-推送镜像push class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#5-%e6%8e%a8%e9%80%81%e9%95%9c%e5%83%8fpush aria-label=锚点>#</a></span></h2><p>将本地镜像上传到 Docker 仓库（如 Docker Hub 或私有仓库）。首先需要登录 Docker 仓库：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker login
</span></span></code></pre></div><p>然后使用 <code>docker push</code> 将镜像推送到远程仓库：</p><pre tabindex=0><code>docker push &lt;image_name&gt;:&lt;tag&gt;
</code></pre><p>例如，推送 <code>my-app:latest</code> 镜像到 Docker Hub：</p><pre tabindex=0><code>docker push my-app:latest
</code></pre><h2 class="relative group">6. <strong>删除镜像（Remove）</strong><div id=6-删除镜像remove class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#6-%e5%88%a0%e9%99%a4%e9%95%9c%e5%83%8fremove aria-label=锚点>#</a></span></h2><p>如果不再需要某个镜像，可以使用 <code>docker rmi</code> 命令删除它。删除镜像时，Docker 会检查该镜像是否被容器使用，若被使用则无法删除。</p><pre tabindex=0><code>docker rmi &lt;image_name&gt;:&lt;tag&gt;
</code></pre><p>例如，删除 <code>my-app:latest</code> 镜像：</p><pre tabindex=0><code>docker rmi my-app:latest
</code></pre><p>如果镜像被多个标签引用，可以一次性删除多个标签的镜像：</p><pre tabindex=0><code>docker rmi &lt;image_id&gt;
</code></pre><p>如果没有删除所有的镜像，怎只会解除当前镜像的tag，而不会删除源镜像</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#删全部</span>
</span></span><span class=line><span class=cl>docker rmi -f <span class=k>$(</span>docker images -qa<span class=k>)</span> 
</span></span></code></pre></div><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image-20241207112911380 src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412071129482.png></figure><h2 class="relative group">7. <strong>清理未使用的镜像</strong><div id=7-清理未使用的镜像 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#7-%e6%b8%85%e7%90%86%e6%9c%aa%e4%bd%bf%e7%94%a8%e7%9a%84%e9%95%9c%e5%83%8f aria-label=锚点>#</a></span></h2><p>Docker 会产生很多没有被使用的镜像，这些镜像会占用磁盘空间。使用 <code>docker system prune</code> 或 <code>docker image prune</code> 命令清理未使用的镜像、容器、网络和构建缓存。</p><pre tabindex=0><code>docker system prune
</code></pre><h2 class="relative group">8. <strong>查看镜像历史</strong><div id=8-查看镜像历史 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#8-%e6%9f%a5%e7%9c%8b%e9%95%9c%e5%83%8f%e5%8e%86%e5%8f%b2 aria-label=锚点>#</a></span></h2><p>使用 <code>docker history</code> 命令可以查看镜像的构建历史。它列出了镜像的每一层及其创建的命令。</p><pre tabindex=0><code>docker history &lt;image_name&gt;:&lt;tag&gt;
</code></pre><p>例如，查看 <code>ubuntu:20.04</code> 镜像的历史：</p><pre tabindex=0><code>docker history ubuntu:20.04
</code></pre><h2 class="relative group">9. <strong>镜像仓库</strong><div id=9-镜像仓库 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#9-%e9%95%9c%e5%83%8f%e4%bb%93%e5%ba%93 aria-label=锚点>#</a></span></h2><p>Docker 镜像通常存储在仓库中。Docker Hub 是默认的公共镜像仓库，用户也可以使用私有仓库存储镜像。常见的 Docker 镜像仓库有：</p><ul><li><strong>Docker Hub</strong>：Docker 官方公共镜像仓库</li><li><strong>私有镜像仓库</strong>：通过 Docker Registry 创建自己的私有镜像仓库，适合企业内部使用</li></ul><h2 class="relative group">10. 导入及导出镜像<div id=10-导入及导出镜像 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#10-%e5%af%bc%e5%85%a5%e5%8f%8a%e5%af%bc%e5%87%ba%e9%95%9c%e5%83%8f aria-label=锚点>#</a></span></h2><h4 class="relative group">导出镜像为tar包<div id=导出镜像为tar包 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e5%af%bc%e5%87%ba%e9%95%9c%e5%83%8f%e4%b8%batar%e5%8c%85 aria-label=锚点>#</a></span></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 直接导出为tar包</span>
</span></span><span class=line><span class=cl>docker save -o  image.tar  image:tag
</span></span><span class=line><span class=cl>docker save image_id -o /home/mysql.tar
</span></span><span class=line><span class=cl>docker save image_id &gt; /home/mysql.tar
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#导出多个镜像为1个tar包</span>
</span></span><span class=line><span class=cl>docker save -o &lt;output-file.tar&gt; &lt;image1&gt;:&lt;tag1&gt; &lt;image2&gt;:&lt;tag2&gt; ...
</span></span></code></pre></div><h4 class="relative group">导入tar包为镜像<div id=导入tar包为镜像 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e5%af%bc%e5%85%a5tar%e5%8c%85%e4%b8%ba%e9%95%9c%e5%83%8f aria-label=锚点>#</a></span></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker load -i mysql.tar
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># docker load -i /usr/local/rancher-v2.3.5.tar</span>
</span></span><span class=line><span class=cl>43c67172d1d1: Loading layer <span class=o>[==================================================</span>&gt;<span class=o>]</span>  65.57MB/65.57MB
</span></span><span class=line><span class=cl>21ec61b65b20: Loading layer <span class=o>[==============================</span>......
</span></span><span class=line><span class=cl>c22c9a5a8211: Loading layer <span class=o>[==================================================</span>&gt;<span class=o>]</span>  3.072kB/3.072kB
</span></span><span class=line><span class=cl>Loaded image: rancher/rancher:v2.3.5
</span></span></code></pre></div><h2 class="relative group">11. 备份镜像<div id=11-备份镜像 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#11-%e5%a4%87%e4%bb%bd%e9%95%9c%e5%83%8f aria-label=锚点>#</a></span></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker save <span class=k>$(</span>docker images <span class=p>|</span> sed 1d <span class=p>|</span> awk 
</span></span><span class=line><span class=cl>‘<span class=o>{</span>print <span class=nv>$1</span><span class=o>}</span>’<span class=k>)</span> &gt; centos-all.tar
</span></span></code></pre></div><h2 class="relative group"><strong>常见镜像命令总结</strong><div id=常见镜像命令总结 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e5%b8%b8%e8%a7%81%e9%95%9c%e5%83%8f%e5%91%bd%e4%bb%a4%e6%80%bb%e7%bb%93 aria-label=锚点>#</a></span></h2><table><thead><tr><th>命令</th><th>作用</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><code>docker images</code></td><td>列出所有本地镜像</td><td></td><td></td><td></td><td></td></tr><tr><td><code>docker pull &lt;image_name></code></td><td>从仓库拉取镜像</td><td></td><td></td><td></td><td></td></tr><tr><td><code>docker build -t &lt;name>:&lt;tag></code></td><td>根据 Dockerfile 构建镜像</td><td></td><td></td><td></td><td></td></tr><tr><td><code>docker tag &lt;image> &lt;new_tag></code></td><td>为镜像添加标签</td><td></td><td></td><td></td><td></td></tr><tr><td><code>docker push &lt;image></code></td><td>推送镜像到远程仓库</td><td></td><td></td><td></td><td></td></tr><tr><td><code>docker rmi &lt;image></code></td><td>删除本地镜像</td><td></td><td></td><td></td><td></td></tr><tr><td><code>docker system prune</code></td><td>清理无用的镜像、容器、网络等</td><td></td><td></td><td></td><td></td></tr><tr><td>docker save -o <image></td><td>保存镜像到本地</td><td></td><td></td><td></td><td></td></tr><tr><td>docker load -i <image></td><td>导入本地镜像</td><td></td><td></td><td></td><td></td></tr></tbody></table><h1 class="relative group">三、Docker容器管理<div id=三docker容器管理 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e4%b8%89docker%e5%ae%b9%e5%99%a8%e7%ae%a1%e7%90%86 aria-label=锚点>#</a></span></h1><h2 class="relative group">1. 容器概述<div id=1-容器概述 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#1-%e5%ae%b9%e5%99%a8%e6%a6%82%e8%bf%b0 aria-label=锚点>#</a></span></h2><h3 class="relative group">1.1 什么是容器<div id=11-什么是容器 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#11-%e4%bb%80%e4%b9%88%e6%98%af%e5%ae%b9%e5%99%a8 aria-label=锚点>#</a></span></h3><ul><li>通过Image创建(copy)</li><li>在Image layer之上建立一个container layer（可读写）</li><li>类比面向对象：类和实例</li><li>Image负责app的存储和分发，Container负责运行app</li></ul><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image-20241207110635002 src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412071106113.png></figure><h3 class="relative group">1.2 容器与镜像的关系<div id=12-容器与镜像的关系 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#12-%e5%ae%b9%e5%99%a8%e4%b8%8e%e9%95%9c%e5%83%8f%e7%9a%84%e5%85%b3%e7%b3%bb aria-label=锚点>#</a></span></h3><ul><li>镜像：镜像是只读文件，提供运行程序完整的软硬件资源。</li><li>容器：容器是镜像的实例，由docker负责创建，容器之间彼此隔离</li></ul><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image-20241207110852667 src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412071108782.png></figure><h2 class="relative group">2. 容器的使用<div id=2-容器的使用 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#2-%e5%ae%b9%e5%99%a8%e7%9a%84%e4%bd%bf%e7%94%a8 aria-label=锚点>#</a></span></h2><h3 class="relative group">2.1 <strong>启动容器（Run）</strong><div id=21-启动容器run class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#21-%e5%90%af%e5%8a%a8%e5%ae%b9%e5%99%a8run aria-label=锚点>#</a></span></h3><p>使用 <code>docker run</code> 命令可以从镜像启动一个新的容器，并运行指定的命令。该命令也可用来设置容器的环境变量、挂载卷、设置端口映射等。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run <span class=o>[</span>OPTIONS<span class=o>]</span> &lt;image_name&gt; <span class=o>[</span>COMMAND<span class=o>]</span>
</span></span></code></pre></div><p>例如，使用 <code>nginx</code> 镜像启动一个容器，并将本地 80 端口映射到容器的 80 端口：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -d -p 80:80 --name my-nginx nginx
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>eg：
</span></span><span class=line><span class=cl>以ubuntu为例，启动后要交互先声明交互模式，其次交互得需要一个终端，因此参数为-it
</span></span><span class=line><span class=cl>docker run -it ubuntu /bin/bash  <span class=c1>#伪终端登陆</span>
</span></span><span class=line><span class=cl>docker run -it --name<span class=o>=</span>myubuntu ubuntu /bin/bash <span class=c1>#指定名称</span>
</span></span><span class=line><span class=cl>docker run -d redis:6.0.8   <span class=c1>#后台运行、守护式容器</span>
</span></span><span class=line><span class=cl>注意
</span></span><span class=line><span class=cl>上面的docker run -d ubuntu 执行后，使用docker ps -a进行查看，会发现容器已经退出
</span></span><span class=line><span class=cl>很重要的要说明的一点: Docker容器后台运行,就必须有一个前台进程.
</span></span></code></pre></div><p>常用选项：</p><ul><li><code>-d</code>：后台运行容器（即脱离终端）</li><li><code>-p</code>：端口映射</li><li><code>--name</code>：给容器指定一个名字</li><li><code>-e</code>：设置环境变量</li></ul><table><thead><tr><th><strong>选项</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>-i, --interactive</code></td><td>交互式模式，保持容器标准输入打开</td></tr><tr><td><code>-t, --tty</code></td><td>分配一个伪终端，用于连接到容器的终端</td></tr><tr><td><code>-d, --detach</code></td><td>在后台运行容器，不阻塞终端</td></tr><tr><td><code>-e, --env</code></td><td>设置环境变量，格式：<code>-e &lt;key>=&lt;value></code></td></tr><tr><td><code>-p, --publish list</code></td><td>发布容器端口到主机，格式：<code>-p &lt;host_port>:&lt;container_port></code></td></tr><tr><td><code>-P, --publish-all</code></td><td>发布容器所有 EXPOSE 的端口到宿主机随机端口</td></tr><tr><td><code>--name string</code></td><td>指定容器的名称</td></tr><tr><td><code>-h, --hostname</code></td><td>设置容器的主机名</td></tr><tr><td><code>--ip string</code></td><td>指定容器的 IP 地址，仅限于自定义网络</td></tr><tr><td><code>--network</code></td><td>连接容器到指定的网络</td></tr><tr><td><code>-v, --volume list</code></td><td>将宿主机目录或卷挂载到容器中，格式：<code>-v &lt;host_path>:&lt;container_path></code></td></tr><tr><td><code>--mount mount</code></td><td>使用新方式将文件系统或存储挂载到容器，格式：<code>--mount type=bind,source=&lt;source>,target=&lt;target></code></td></tr><tr><td><code>--restart string</code></td><td>设置容器退出时的重启策略，默认值为 <code>no</code>，可选值：[always</td></tr><tr><td><code>-m, --memory</code></td><td>限制容器的最大内存使用量</td></tr><tr><td><code>--memory-swap</code></td><td>容器允许使用的交换空间大小（包括内存和 swap）</td></tr><tr><td><code>--memory-swappiness=&lt;0-100></code></td><td>设置容器使用 swap 的倾向性，取值范围 [0-100]，默认为 -1</td></tr><tr><td><code>--oom-kill-disable</code></td><td>禁用 OOM Killer，当容器内存耗尽时不会被杀掉</td></tr><tr><td><code>--cpus</code></td><td>设置容器可以使用的 CPU 数量</td></tr><tr><td><code>--cpuset-cpus</code></td><td>限制容器使用特定的 CPU 核心，如 <code>--cpuset-cpus="0-3,0,1"</code></td></tr><tr><td><code>--cpu-shares</code></td><td>设置容器的 CPU 权重，用于 CPU 资源的分配（相对权重）</td></tr></tbody></table><h3 class="relative group">2.2 <strong>查看容器列表</strong><div id=22-查看容器列表 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#22-%e6%9f%a5%e7%9c%8b%e5%ae%b9%e5%99%a8%e5%88%97%e8%a1%a8 aria-label=锚点>#</a></span></h3><p>使用 <code>docker ps</code> 命令查看当前正在运行的容器。如果要查看所有容器（包括已停止的），可以使用 <code>docker ps -a</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker ps            <span class=c1># 查看正在运行的容器</span>
</span></span><span class=line><span class=cl>docker ps -a         <span class=c1># 查看所有容器，包括已停止的</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>参数：
</span></span><span class=line><span class=cl>-a :列出当前所有正在运行的容器+历史上运行过的
</span></span><span class=line><span class=cl>-l :显示最近创建的容器。
</span></span><span class=line><span class=cl>-n nu：显示最近nu个创建的容器。
</span></span><span class=line><span class=cl>-q :静默模式，只显示容器编号。
</span></span></code></pre></div><p>输出示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                  NAMES
</span></span><span class=line><span class=cl>1a2b3c4d5e6f   nginx     <span class=s2>&#34;/docker-entrypoint.…&#34;</span>   <span class=m>2</span> minutes ago   Up <span class=m>2</span> minutes   0.0.0.0:80-&gt;80/tcp     my-nginx
</span></span></code></pre></div><h3 class="relative group">2.3 <strong>进入、退出容器</strong><div id=23-进入退出容器 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#23-%e8%bf%9b%e5%85%a5%e9%80%80%e5%87%ba%e5%ae%b9%e5%99%a8 aria-label=锚点>#</a></span></h3><h4 class="relative group">进入容器<div id=进入容器 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e8%bf%9b%e5%85%a5%e5%ae%b9%e5%99%a8 aria-label=锚点>#</a></span></h4><p>如果想要进入容器的内部进行调试或操作，可以使用 <code>docker exec</code> 命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker <span class=nb>exec</span> -it &lt;container_id_or_name&gt; /bin/bash
</span></span></code></pre></div><p>例如，进入名为 <code>my-nginx</code> 的容器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker <span class=nb>exec</span> -it my-nginx /bin/bash
</span></span></code></pre></div><h4 class="relative group">退出容器<div id=退出容器 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e9%80%80%e5%87%ba%e5%ae%b9%e5%99%a8 aria-label=锚点>#</a></span></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>① <span class=nb>exit</span>
</span></span><span class=line><span class=cl>run进去容器，exit退出，容器停止
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>② ctrl+p+q
</span></span><span class=line><span class=cl>run进去容器，ctrl+p+q退出，容器不停止
</span></span></code></pre></div><h4 class="relative group">容器内外的文件复制<div id=容器内外的文件复制 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e5%ae%b9%e5%99%a8%e5%86%85%e5%a4%96%e7%9a%84%e6%96%87%e4%bb%b6%e5%a4%8d%e5%88%b6 aria-label=锚点>#</a></span></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker cp  容器ID:容器内路径 目的主机路径   <span class=c1>#从容器内拷贝文件到主机上</span>
</span></span><span class=line><span class=cl>eg:
</span></span><span class=line><span class=cl><span class=c1>#以ubuntu为例，我们在/tmp目录下通过touch a.txt创建a文本，将其复制到本机download目录下</span>
</span></span><span class=line><span class=cl>docker cp 958443b97285:/tmp/a.txt /download
</span></span><span class=line><span class=cl><span class=c1>#有一个名为 my_container 的容器，并且希望将主机上的文件 /tmp/myfile.txt 复制到容器内的 /app 目录：</span>
</span></span><span class=line><span class=cl>docker cp /tmp/myfile.txt my_container:/app/
</span></span></code></pre></div><h3 class="relative group">2.4 <strong>停止容器</strong><div id=24--停止容器 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#24--%e5%81%9c%e6%ad%a2%e5%ae%b9%e5%99%a8 aria-label=锚点>#</a></span></h3><p>要停止一个运行中的容器，使用 <code>docker stop</code> 命令。可以根据容器的 ID 或名称停止容器。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker stop &lt;container_id_or_name&gt;
</span></span></code></pre></div><p>例如，停止名为 <code>my-nginx</code> 的容器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker stop my-nginx
</span></span></code></pre></div><h3 class="relative group">2.5 <strong>重启容器</strong><div id=25-重启容器 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#25-%e9%87%8d%e5%90%af%e5%ae%b9%e5%99%a8 aria-label=锚点>#</a></span></h3><p>要重启一个容器，可以使用 <code>docker restart</code> 命令，这对于更新配置或者重启容器应用非常有用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker restart &lt;container_id_or_name&gt;
</span></span></code></pre></div><p>例如，重启名为 <code>my-nginx</code> 的容器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker restart my-nginx
</span></span></code></pre></div><h3 class="relative group">2.6 <strong>删除容器</strong><div id=26-删除容器 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#26-%e5%88%a0%e9%99%a4%e5%ae%b9%e5%99%a8 aria-label=锚点>#</a></span></h3><p>删除已停止的容器，可以使用 <code>docker rm</code> 命令。需要注意的是，删除容器时，该容器内的数据会丢失，除非使用了卷（Volumes）来持久化数据。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker rm &lt;container_id_or_name&gt;
</span></span></code></pre></div><p>例如，删除名为 <code>my-nginx</code> 的容器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker rm my-nginx
</span></span></code></pre></div><p>如果容器在运行，且你希望同时停止并删除它，可以使用 <code>-f</code> 强制删除容器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker rm -f &lt;container_id_or_name&gt;
</span></span></code></pre></div><h3 class="relative group">2.7 <strong>查看容器日志</strong><div id=27--查看容器日志 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#27--%e6%9f%a5%e7%9c%8b%e5%ae%b9%e5%99%a8%e6%97%a5%e5%bf%97 aria-label=锚点>#</a></span></h3><p>要查看容器的日志输出，可以使用 <code>docker logs</code> 命令。这对于调试应用程序或排查错误非常有用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker logs &lt;container_id_or_name&gt;
</span></span></code></pre></div><p>例如，查看名为 <code>my-nginx</code> 容器的日志：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker logs my-nginx
</span></span></code></pre></div><p>如果要实时查看日志，可以使用 <code>-f</code> 选项：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker logs -f &lt;container_id_or_name&gt;
</span></span></code></pre></div><h3 class="relative group">2.8 <strong>查看容器的详细情况</strong><div id=28-查看容器的详细情况 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#28-%e6%9f%a5%e7%9c%8b%e5%ae%b9%e5%99%a8%e7%9a%84%e8%af%a6%e7%bb%86%e6%83%85%e5%86%b5 aria-label=锚点>#</a></span></h3><p>要查看容器的资源使用情况（如 CPU、内存等），可以使用 <code>docker stats</code> 命令。它会显示所有容器的资源使用信息，或者你可以指定某个容器查看其资源使用情况。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker stats          <span class=c1># 查看所有容器的资源使用情况</span>
</span></span><span class=line><span class=cl>docker stats &lt;container_id_or_name&gt;  <span class=c1># 查看指定容器的资源使用情况</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>参数：
</span></span><span class=line><span class=cl>--all , -a :显示所有的容器，包括未运行的。
</span></span><span class=line><span class=cl>--format :指定返回值的模板文件。
</span></span><span class=line><span class=cl>--no-stream :展示当前状态就直接退出了，不再实时更新。
</span></span><span class=line><span class=cl>--no-trunc :不截断输出。
</span></span><span class=line><span class=cl>eg：
</span></span><span class=line><span class=cl>docker stats
</span></span><span class=line><span class=cl>docker stats mynginx  <span class=c1># 容器名</span>
</span></span><span class=line><span class=cl>docker stats af7928654200  <span class=c1># 容器ID</span>
</span></span></code></pre></div><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image-20241207213851198 src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072138334.png></figure><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>字段解析
</span></span><span class=line><span class=cl>CONTAINER ID 与 NAME: 容器 ID 与名称。
</span></span><span class=line><span class=cl>CPU % 与 MEM %: 容器使用的 CPU 和内存的百分比。
</span></span><span class=line><span class=cl>MEM USAGE / LIMIT: 容器正在使用的总内存，以及允许使用的内存总量。
</span></span><span class=line><span class=cl>NET I/O: 容器通过其网络接口发送和接收的数据量。
</span></span><span class=line><span class=cl>BLOCK I/O: 容器从主机上的块设备读取和写入的数据量。
</span></span><span class=line><span class=cl>PIDs: 容器创建的进程或线程数。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># docker stats统计结果只能是当前宿主机的全部容器，数据资料是实时的，没有地方存储、没有健康指标过线预警等功能，如果现象要实现监控数据持久化并以图表等形式展现，可以使用CIG，即CAdvisor监控收集+InfluxDB存储数据+Granfana展示图表</span>
</span></span></code></pre></div><p>要查看容器里的进程使用情况，使用<code>docker top</code> 查看容器内的进程</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker top 容器ID   <span class=c1>#查看容器内运行的进程</span>
</span></span></code></pre></div><h3 class="relative group">2.9 <strong>管理容器网络</strong><div id=29--管理容器网络 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#29--%e7%ae%a1%e7%90%86%e5%ae%b9%e5%99%a8%e7%bd%91%e7%bb%9c aria-label=锚点>#</a></span></h3><p>Docker 容器之间可以通过 Docker 网络进行通信。你可以创建自定义网络、连接容器到网络，或者查看网络配置。</p><ul><li><p>创建网络：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker network create &lt;network_name&gt;
</span></span></code></pre></div></li><li><p>连接容器到指定网络：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker network connect &lt;network_name&gt; &lt;container_id_or_name&gt;
</span></span></code></pre></div></li><li><p>查看容器网络：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker network ls
</span></span></code></pre></div></li><li><p>删除网络</p></li><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker network rm XXX网络名字  
</span></span></code></pre></div></li><li><p>查看网络相关信息</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker network inspect  XXX网络名字   
</span></span></code></pre></div><h3 class="relative group">2.10 <strong>容器与卷（Volumes）</strong><div id=210-容器与卷volumes class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#210-%e5%ae%b9%e5%99%a8%e4%b8%8e%e5%8d%b7volumes aria-label=锚点>#</a></span></h3><h4 class="relative group">使用卷<div id=使用卷 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e4%bd%bf%e7%94%a8%e5%8d%b7 aria-label=锚点>#</a></span></h4><p>为了持久化容器中的数据，可以使用 Docker 卷（Volumes）。卷存储在 Docker 守护进程外部，容器停止或删除时，卷中的数据不会丢失。可以将容器中的目录挂载到卷上。</p><ul><li><p>创建一个卷：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker volume create &lt;volume_name&gt;
</span></span></code></pre></div></li><li><p>使用卷启动容器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -d -v &lt;volume_name&gt;:&lt;container_path&gt; &lt;image_name&gt;
</span></span></code></pre></div></li></ul><p>例如，使用 <code>my-volume</code> 卷启动一个容器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -d -v my-volume:/data nginx
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -it --privileged<span class=o>=</span><span class=nb>true</span> -v /宿主机绝对路径目录:/容器内目录:<span class=o>[</span>OPTION<span class=o>]</span> 镜像名
</span></span><span class=line><span class=cl>参数：
</span></span><span class=line><span class=cl>rw   可读可写（read + write）
</span></span><span class=line><span class=cl>ro   容器实例内部被限制，只能读取不能写，仅读（read only）
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>eg：
</span></span><span class=line><span class=cl>docker run -it --privileged<span class=o>=</span><span class=nb>true</span> --name<span class=o>=</span>u1 -v /tmp/docker_data:/tmp/dockertest:ro ubuntu /bin/bash
</span></span><span class=line><span class=cl>docker run -it --privileged<span class=o>=</span><span class=nb>true</span> --name<span class=o>=</span>u2 -v /tmp/docker_data:/tmp/dockertest ubuntu /bin/bash  <span class=c1># 不写OPTION默认rw</span>
</span></span><span class=line><span class=cl>挂载后可通过【docker inspect 容器ID】查看是否挂载成功
</span></span></code></pre></div><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image-20241207214159509 src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072141618.png></figure><h4 class="relative group">容器数据卷继承<div id=容器数据卷继承 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e5%ae%b9%e5%99%a8%e6%95%b0%e6%8d%ae%e5%8d%b7%e7%bb%a7%e6%89%bf aria-label=锚点>#</a></span></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -it  --privileged<span class=o>=</span><span class=nb>true</span> --volumes-from 父类  --name u2 ubuntu
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>example：
</span></span><span class=line><span class=cl><span class=c1># 新创建u3容器继承u2容器的数据卷挂载，此时u2就算stop也不影响u3</span>
</span></span><span class=line><span class=cl>docker run -it --privileged<span class=o>=</span><span class=nb>true</span> --volumes-from u2 --name u3 ubuntu
</span></span></code></pre></div><h3 class="relative group">2.11 容器的备份<div id=211-容器的备份 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#211-%e5%ae%b9%e5%99%a8%e7%9a%84%e5%a4%87%e4%bb%bd aria-label=锚点>#</a></span></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker commit -m<span class=o>=</span><span class=s2>&#34;提交的描述信息&#34;</span> -a<span class=o>=</span><span class=s2>&#34;作者&#34;</span> 容器ID 要创建的目标镜像名:<span class=o>[</span>标签名<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=c1># 保存当前容器的状态</span>
</span></span><span class=line><span class=cl>docker commit -a <span class=s2>&#34;author&#34;</span> -m <span class=s2>&#34;meassage&#34;</span> container_id
</span></span><span class=line><span class=cl>docker commit -a <span class=s2>&#34;author&#34;</span> -m <span class=s2>&#34;meassage&#34;</span> container_name
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>eg:
</span></span><span class=line><span class=cl>docker pull ubuntu
</span></span><span class=line><span class=cl>docker <span class=nb>exec</span> --it container_id /bin/bash
</span></span><span class=line><span class=cl>apt-get update
</span></span><span class=line><span class=cl>apt-get -y install vim
</span></span><span class=line><span class=cl>docker commit -m<span class=o>=</span><span class=s2>&#34;ubuntu-add-vim&#34;</span> -a<span class=o>=</span><span class=s2>&#34;zjy&#34;</span> a4b1b1cc54f0  atguigu/myubuntu:1.3
</span></span><span class=line><span class=cl>验证：
</span></span><span class=line><span class=cl>docker systemd df
</span></span><span class=line><span class=cl>docker images -a
</span></span></code></pre></div><p><em>仅会保存当前容器内的文件（包括cp进容器的文件），但不会保存挂载的volume或bind</em></p><h3 class="relative group">2.12常见容器命令总结<div id=212常见容器命令总结 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#212%e5%b8%b8%e8%a7%81%e5%ae%b9%e5%99%a8%e5%91%bd%e4%bb%a4%e6%80%bb%e7%bb%93 aria-label=锚点>#</a></span></h3><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>docker ps</code></td><td>列出当前运行中的容器</td></tr><tr><td><code>docker inspect</code></td><td>查看一个或多个容器的详细信息</td></tr><tr><td><code>docker exec</code></td><td>在运行中的容器内执行命令</td></tr><tr><td><code>docker commit</code></td><td>从容器创建一个新的镜像</td></tr><tr><td><code>docker cp</code></td><td>拷贝文件或文件夹到容器中或从容器中拷贝到主机</td></tr><tr><td><code>docker logs</code></td><td>获取容器的日志输出</td></tr><tr><td><code>docker port</code></td><td>列出或指定容器端口映射</td></tr><tr><td><code>docker top</code></td><td>显示容器中运行的进程</td></tr><tr><td><code>docker stats</code></td><td>显示容器的实时资源使用统计信息</td></tr><tr><td><code>docker stop</code></td><td>停止一个或多个运行中的容器</td></tr><tr><td><code>docker start</code></td><td>启动一个或多个已停止的容器</td></tr><tr><td><code>docker restart</code></td><td>重启一个或多个容器</td></tr><tr><td><code>docker rm</code></td><td>删除一个或多个容器</td></tr><tr><td><code>docker prune</code></td><td>移除所有已停止的容器，并释放占用的系统资源</td></tr></tbody></table><h1 class="relative group">四、Docker网络管理<div id=四docker网络管理 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e5%9b%9bdocker%e7%bd%91%e7%bb%9c%e7%ae%a1%e7%90%86 aria-label=锚点>#</a></span></h1><p>Docker网络架构的设计规范是CNM。CNM中规定了Docker网络的基础组成要素，完整内容见GitHub的docker/libnetwork库。</p><p>推荐通篇阅读该规范，不过其实抽象来讲，CNM定义了3个基本要素：沙盒（Sandbox）、终端（Endpoint）和网络（Network）。</p><p>沙盒是一个独立的网络栈。<strong>其中包括以太网接口、端口、路由表以及<strong><strong>DNS</strong></strong>配置。</strong></p><p>终端就是虚拟网络接口。<strong>就像普通网络接口一样</strong>，终端主要职责是负责创建连接。在CNM中，终端负责将沙盒连接到网络。</p><p>网络是802.1d网桥（类似大家熟知的交换机）的软件实现。因此，网络就是需要交互的终端的集合，并且终端之间相互独立</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image.png src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072216003.png></figure><p>Docker环境中最小的调度单位就是容器，而CNM也恰如其名，负责为容器提供网络功能。</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image.png src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072217981.png></figure><p><em>需要重点理解的是，终端与常见的网络适配器类似，这意味着终端只能接入某一个网络。因此，如果容器需要接入到多个网络，就需要多个终端。</em></p><p>网络部分代码都存在于daemon当中,Docker将该网络部分从daemon中拆分，并重构为一个叫作Libnetwork的外部类库。</p><p>Libnetwork实现了CNM中定义的全部3个组件。此外它还实现了本地服务发现（Service Discovery）、基于Ingress的容器负载均衡，以及网络控制层和管理层功能。</p><p>如果说Libnetwork实现了控制层和管理层功能，那么驱动就负责实现数据层。比如，网络连通性和隔离性是由驱动来处理的，驱动层实际创建网络对象也是如此，其关系如图所示。</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image.png src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072220784.png></figure><p>Docker封装了若干内置驱动，通常被称作原生驱动或者本地驱动。在Linux上包括Bridge 、Overlay 以及Macvlan</p><h2 class="relative group">1. Bridge<div id=1-bridge class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#1-bridge aria-label=锚点>#</a></span></h2><h3 class="relative group">默认Bridge<div id=默认bridge class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e9%bb%98%e8%ae%a4bridge aria-label=锚点>#</a></span></h3><p>当 Docker 进程启动时，会在主机上创建一个名为 docker0 的虚拟网桥，此主机上启动的 Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</p><p>从 docker0 子网中分配一个 IP 给容器使用，并设置 docker0 的 IP 地址为容器的默认网关。在主机上创建一对虚拟网卡 <code>veth pair</code> 设备， Docker将 <code>veth pair</code> 设备的一端放在新创建的容器中，并命名为<code> eth0</code> （容器的网卡），另一端放在主机中，以 vethxxx 这样类似的名字命名，并将这个网络设备加入到 docker0 网桥中。可以通过<code>brctl show</code>命令查看</p><img src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/image-20241206010034904.png alt=image-20241206010034904 style=zoom:67%><p>Docker默认“bridge”网络和Linux内核中的“docker0”网桥之间的关系如图</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image.png src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072223578.png></figure><h3 class="relative group">自定义Bridge<div id=自定义bridge class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e8%87%aa%e5%ae%9a%e4%b9%89bridge aria-label=锚点>#</a></span></h3><p>使用docker network create 命令创建新的单机桥接网络，名为“localnet”。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl> docker network create -d bridge localnet
</span></span></code></pre></div><p>新的网络创建成功，并且会出现在<code>docker network ls</code> 命名的输出内容当中。如果读者使用Linux，那么在主机内核中还会创建一个新的Linux网桥</p><p>接下来通过使用Linux brctl 工具来查看系统中的Linux网桥。可能需要通过命令apt-get install bridge-utils 来安装brctl 二进制包，或者根据所使用的Linux发行版选择合适的命令。</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image.png src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072227038.png></figure><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>root@blog:/home/hwz# brctl show
</span></span><span class=line><span class=cl>bridge name                    bridge id             STP enabled        interfaces
</span></span><span class=line><span class=cl>br-5ac679535b8c         8000.0242858a17dd        no              veth4b19961                                                      docker0                       8000.0242ac80c4ca         no              vethf1e3e13
</span></span><span class=line><span class=cl>docker_gwbridge         8000.02425bb9fa03         no              vethaad561c
</span></span></code></pre></div><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image.png src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072231189.png></figure><p><em><strong>Linux</strong>上默认的</em><em>Bridge</em><em>网络是不支持通过</em><em>Docker DNS</em>*服务进行域名解析的。自定义桥接网络可以*！</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>（1）创建名为“c2”的容器，并接入“c1”所在的localnet 网络。
</span></span><span class=line><span class=cl>//Linux
</span></span><span class=line><span class=cl>$ docker container run -it --name c2 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>--network localnet <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>alpine sh
</span></span><span class=line><span class=cl>（2）在“c2”容器中，通过“c1”容器名称执行ping 命令。
</span></span><span class=line><span class=cl>&gt; ping c1
</span></span><span class=line><span class=cl>Pinging c1 <span class=o>[</span>172.26.137.130<span class=o>]</span> with <span class=m>32</span> bytes of data:
</span></span><span class=line><span class=cl>Reply from 172.26.137.130: <span class=nv>bytes</span><span class=o>=</span><span class=m>32</span> <span class=nv>time</span><span class=o>=</span>1ms <span class=nv>TTL</span><span class=o>=</span><span class=m>128</span>
</span></span><span class=line><span class=cl>Reply from 172.26.137.130: <span class=nv>bytes</span><span class=o>=</span><span class=m>32</span> <span class=nv>time</span><span class=o>=</span>1ms <span class=nv>TTL</span><span class=o>=</span><span class=m>128</span>
</span></span><span class=line><span class=cl>Control-C
</span></span></code></pre></div><p>命令生效了！这是因为c2容器运行了一个本地DNS解析器，该解析器将请求转发到了Docker内部DNS服务器当中。Docker的 DNS服务器中记录了容器启动时通过&ndash;name 或者&ndash;net-alias 参数指定的名称与容器之间的映射关系。</p><p>**桥接网络中的容器只能与位于相同网络中的容器进行通信。**但是，可以使用端口映射（Port Mapping）来绕开这个限制。</p><p>在端口映射时，Docker 并不关心宿主机和容器的 IP 地址是否在同一网段。Docker 负责处理从宿主机接收到的流量，并将其转发到正确的容器。<strong>端口映射的关键在于网络层面的路由和 NAT 转换，而不是 IP 地址的直接通信</strong>。</p><p>端口映射允许将某个容器端口映射到Docker主机端口上。对于配置中指定的Docker主机端口，任何发送到该端口的流量，都会被转发到容器。图中展示了具体流量动向。</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image.png src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072235925.png></figure><h2 class="relative group">2. Container<div id=2-container class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#2-container aria-label=锚点>#</a></span></h2><p>指定新创建的容器和已经存在的一个容器共享一个 Network Namespace ，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP ，而是和一个指定的容器共享 IP 、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 参数</span>
</span></span><span class=line><span class=cl>docker run --network container:&lt;container_id&gt; &lt;image&gt;
</span></span><span class=line><span class=cl>新的容器将共享指定容器的网络堆栈，包括 IP 地址、端口等。这种模式使得多个容器可以共享网络配置，但并没有独立的网络空间。
</span></span></code></pre></div><img src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/image-20241206010552485.png alt=image-20241206010552485 style=zoom:50%><h2 class="relative group">3. Host<div id=3-host class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#3-host aria-label=锚点>#</a></span></h2><p>如果启动容器的时候使用 host 模式，那么这个容器将不会获得一个独立的 Network Namespace ，而是和宿主机共用一个 Network Namespace 。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run --network host &lt;image&gt;
</span></span></code></pre></div><img src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/image-20241206010142828.png alt=image-20241206010142828 style=zoom:50%><h2 class="relative group">4.None<div id=4none class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#4none aria-label=锚点>#</a></span></h2><ul><li><code>none</code> 网络模式会为容器分配一个独立的网络命名空间，但该容器没有任何网络连接。</li><li><strong>工作原理</strong>：容器在 <code>none</code> 网络模式下不会自动连接到任何网络，容器没有 IP 地址，也不能访问外部网络。你需要手动配置容器的网络连接（如使用 <code>docker exec</code> 进入容器并进行手动配置），或者通过手动创建虚拟网络设备来实现容器间的通信。</li><li><strong>适用场景</strong>：适用于需要完全控制容器网络配置的场景，或者你希望容器完全没有网络访问权限时（例如，做一个完全隔离的安全容器）。</li></ul><img src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/image-20241206010611280.png alt=image-20241206010611280 style=zoom:50%><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run --network none &lt;image&gt;
</span></span></code></pre></div><table><thead><tr><th><strong>网络模式</strong></th><th><strong>描述</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>Bridge</strong></td><td>默认网络，容器连接到虚拟桥接网络</td><td>多个容器需要相互通信并且可以与宿主机或外部网络通信。</td></tr><tr><td><strong>Container</strong></td><td>容器共享另一个容器的网络堆栈</td><td>紧密集成的容器共享网络和端口，如运行多个服务的容器。</td></tr><tr><td><strong>Host</strong></td><td>容器与宿主机共享网络堆栈</td><td>网络性能要求高的应用，且不介意容器与宿主机缺乏隔离。</td></tr><tr><td><strong>None</strong></td><td>容器没有任何网络连接</td><td>完全隔离的容器或需要手动配置网络的特殊场景。</td></tr></tbody></table><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=屏幕截图(70) src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%2870%29.png></figure><h2 class="relative group">5. Overlay<div id=5-overlay class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#5-overlay aria-label=锚点>#</a></span></h2><p>覆盖网络适用于多机环境。它允许单个网络包含多个主机，这样不同主机上的容器间就可以在链路层实现通信。覆盖网络是理想的容器间通信方式，支持完全容器化的应用，并且具备良好的伸缩性。<strong>这种网络类型特别适用于容器编排和集群环境，如Docker Swarm 或 Kubernetes</strong></p><p>即使容器所在的Docker主机位于不同的底层网络上，该覆盖网络依然是相通的。本质上说，覆盖网络是创建于底层异构网络之上的一个新的二层容器网络。<figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image.png src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072214608.png></figure></p><p>两个底层网络通过一个三层交换机连接，而基于这两个网络之上是一个覆盖网络。Docker主机通过两个底层网络相连，而容器则通过覆盖网络相连。对于同一覆盖网络中的容器来说，即使其各自所在的Docker主机接入的是不同的底层网络，也是互通的</p><p><strong>原理</strong>：虚拟网络：Docker 创建一个虚拟网络，覆盖在多个物理主机之上。容器可以在这个虚拟网络中相互通信，就像它们在同一个局域网中一样。</p><p>**特点：**无需端口映射：与单机桥接网络不同，overlay 网络中的容器不需要将端口映射到宿主机上。容器可以直接通过 overlay 网络访问其他容器</p><h3 class="relative group">覆盖网络的创建<div id=覆盖网络的创建 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e8%a6%86%e7%9b%96%e7%bd%91%e7%bb%9c%e7%9a%84%e5%88%9b%e5%bb%ba aria-label=锚点>#</a></span></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker network create    -d overlay  net_name
</span></span></code></pre></div><p>要完成下面的示例，需要两台Docker主机，并通过一个路由器上两个独立的二层网络连接在一起。如图所示，注意节点位于不同网络之上</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image.png src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072300607.png></figure><p>Linux内核版本不能低于4.4（高版本更好），Windows需要Windows Server 2016版本，并且应安装最新的补丁</p><p>1．构建Swarm</p><p>首先需要将两台主机配置为包含两个节点的Swarm集群。接下来会在node1节点上运行docker swarm init 命令使其成为管理节点，然后在node2节点上运行docker swarm join 命令来使其成为工作节点。</p><p><em>如果读者需要在自己的环境中继续下面的示例，则需要先将环境中的<strong>IP</strong>地址、容器<strong>ID</strong>和<strong>Token</strong>等替换为正确的值。</em></p><p>在node1 节点上运行下面的命令。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl> $ docker swarm init <span class=se>\ </span>                                       
</span></span><span class=line><span class=cl> ------------------------------------------------------------ 
</span></span><span class=line><span class=cl> --advertise-addr<span class=o>=</span>172.31.1.5 <span class=se>\-</span>-listen-addr<span class=o>=</span>172.31.1.5:2377Swarm initialized: current node <span class=o>(</span>1ex3...o3px<span class=o>)</span> is now a manager. 
</span></span><span class=line><span class=cl> 在node2 上运行下面的命令。如果需要在Windows环境下生效，则需要修改Windows防火墙规则，打开2377/tcp 、7946/tcp 以及7946/udp 等几个端口。 
</span></span><span class=line><span class=cl> $ docker swarm join <span class=se>\ </span>                                       
</span></span><span class=line><span class=cl> --token SWMTKN-1-0hz2ec...2vye <span class=se>\1</span>72.31.1.5:2377This node joined a swarm as a worker. 
</span></span></code></pre></div><p>2．创建新的覆盖网络</p><p>现在创建一个名为uber-net 的覆盖网络。</p><p>在node1 （管理节点）节点上运行下面的命令。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl> $ docker network create -d overlay uber-netc740ydi1lm89khn5kd52skrd9 
</span></span><span class=line><span class=cl>------------------------------------------------------------ 
</span></span><span class=line><span class=cl> 创建了一个崭新的覆盖网络，能连接Swarm集群内的所有主机，并且该网络还包括一个TLS加密的控制层！如果还想对数据层加密的话，只需在命令中增加-o encrypted 参数。 
</span></span><span class=line><span class=cl> $ docker network ls                                          
</span></span><span class=line><span class=cl> NETWORK ID        NAME                  DRIVER     SCOPEddac4ff813b7      bridge            bridge     ocal389a7e7e8607      docker_gwbridge   bridge     locala09f7e6b2ac6      host              host       localehw16ycy980s      ingress           overlay    swarm2b26c11d3469      none              null       local**c740ydi1lm89**      **uber-net**          **overlay**    **swarm** 
</span></span></code></pre></div><p>如果在node2 节点上运行docker network ls 命令，就会发现无法看到uber-net 网络。这是因为只有当运行中的容器连接到覆盖网络的时候，该网络才变为可用状态。这种延迟生效策略通过减少网络梳理，提升了网络的扩展性。</p><p>3．将服务连接到覆盖网络</p><p>现在覆盖网络已经就绪，接下来新建一个Docker服务并连接到该网络。Docker服务会包含两个副本（容器），一个运行在node1 节点上，一个运行在node2 节点上。这样会自动将node2 节点接入uber-net 网络。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl> 在node1节点上运行下面的命令。                                
</span></span><span class=line><span class=cl> ------------------------------------------------------------ 
</span></span><span class=line><span class=cl> $ docker service create --name <span class=nb>test</span> <span class=se>\ </span>                       
</span></span><span class=line><span class=cl> --network uber-net <span class=se>\-</span>-replicas <span class=m>2</span> <span class=se>\u</span>buntu sleep infinity      
</span></span><span class=line><span class=cl>该命令创建了名为test 的新服务，                              
</span></span><span class=line><span class=cl>连接到了uber-net 这个覆盖网络，                              
</span></span><span class=line><span class=cl>基于指定的镜像创建了两个副本（容器）。                      
</span></span><span class=line><span class=cl>在两个示例中，均在容器中采用sleep命令来保持容器运行，并在休眠结束后退出该容器。 
</span></span></code></pre></div><p>由于运行了两个副本（容器），而Swarm包含两个节点，因此每个节点上都会运行一个副本。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl> $ docker service ps <span class=nb>test</span>                                     
</span></span><span class=line><span class=cl> ------------------------------------------------------------ 
</span></span><span class=line><span class=cl> ID            NAME    IMAGE    NODE   DESIRED          STATE  CURRENT STATE
</span></span><span class=line><span class=cl> 77q...rkx   test.1    ubuntu   node1    Running        Running
</span></span><span class=line><span class=cl> 97v...pa5   test.2    ubuntu   node2    Running        Running 
</span></span></code></pre></div><p><strong>当Swarm在覆盖网络之上启动容器时，会自动将容器运行所在节点加入到网络当中。这意味着此时在node2 节点上就可以看到uber-net 网络了</strong></p><p>4．测试覆盖网络</p><p>现在使用ping命令来测试覆盖网络。</p><p>在两个独立的网络中分别有一台Docker主机，并且两者都接入了同一个覆盖网络。目前在每个节点上都有一个容器接入了覆盖网络。测试一下两个容器之间是否可以ping通。</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=img src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072301497.png></figure><p>为了执行该测试，需要知道每个容器的IP地址（为了测试，暂时忽略相同覆盖网络上的容器可以通过名称来互相ping通的事实）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl> 运行docker network inspect 查看被分配给覆盖网络的Subnet 。   
</span></span><span class=line><span class=cl> ------------------------------------------------------------ 
</span></span><span class=line><span class=cl> $ docker network inspect uber-net                            
</span></span><span class=line><span class=cl><span class=o>[{</span><span class=s2>&#34;Name&#34;</span>: <span class=s2>&#34;uber-net&#34;</span>,<span class=s2>&#34;Id&#34;</span>: <span class=s2>&#34;c740ydi1lm89khn5kd52skrd9&#34;</span>,<span class=s2>&#34;Scope&#34;</span>: <span class=s2>&#34;swarm&#34;</span>,<span class=s2>&#34;Driver&#34;</span>: <span class=s2>&#34;overlay&#34;</span>,<span class=s2>&#34;EnableIPv6&#34;</span>: false,<span class=s2>&#34;IPAM&#34;</span>: <span class=o>{</span><span class=s2>&#34;Driver&#34;</span>: <span class=s2>&#34;default&#34;</span>,<span class=s2>&#34;Options&#34;</span>: null,<span class=s2>&#34;Config&#34;</span>: <span class=o>[{</span><span class=s2>&#34;Subnet&#34;</span>: <span class=s2>&#34;10.0.0.0/24&#34;</span>,<span class=s2>&#34;Gateway&#34;</span>: <span class=s2>&#34;10.0.0.1&#34;</span><span class=o>}</span>&lt;Snip&gt; 
</span></span><span class=line><span class=cl>uber-net 的子网是10.0.0.0/24 。注意，这与两个节点的任意底层物理网络IP均不相符（172.31.1.0/24 和192.168.1.0/24 ）。 
</span></span><span class=line><span class=cl>在node1 和node2 节点上运行下面两条命令。这两条命令可以获取到容器ID和IP地址。 
</span></span><span class=line><span class=cl> $ docker container ls                                      
</span></span><span class=line><span class=cl> CONTAINER  ID  IMAGE          COMMAND           CREATED       STATUS
</span></span><span class=line><span class=cl> 396c8b142a85   ubuntu:latest  <span class=s2>&#34;sleep infinity&#34;</span>  <span class=m>2</span> hours ago   Up <span class=m>2</span> hrs 
</span></span><span class=line><span class=cl>$ docker container inspect <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>--format<span class=o>=</span><span class=s1>&#39;{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>396c8b142a85 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>10.0.0.3                                                   
</span></span></code></pre></div><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=img src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072301533.png></figure><p>由图可知，一个二层覆盖网络横跨两台主机，并且每个容器在覆盖网络中都有自己的IP地址。</p><p>这意味着node1 节点上的容器可以通过node2 节点上容器的IP地址10.0.0.4 来ping通，该IP地址属于覆盖网络。尽管两个节点分属于不同的二层网络，还是可以直接ping通。验证如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl> $ docker container <span class=nb>exec</span> -it 396c8b142a85 bash                
</span></span><span class=line><span class=cl> ------------------------------------------------------------ 
</span></span><span class=line><span class=cl> root@396c8b142a85:/# apt-get update                          
</span></span><span class=line><span class=cl>root@396c8b142a85:/# apt-get install iputils-ping            
</span></span><span class=line><span class=cl> Reading package lists... DoneBuilding dependency treeReading state information... DoneSetting up iputils-ping <span class=o>(</span>3:20121221-5ubuntu2<span class=o>)</span> ...Processing triggers <span class=k>for</span> libc-bin <span class=o>(</span>2.23-0ubuntu3<span class=o>)</span> ... 
</span></span><span class=line><span class=cl> root@396c8b142a85:/# ping 10.0.0.4                           
</span></span><span class=line><span class=cl> PING 10.0.0.4 <span class=o>(</span>10.0.0.4<span class=o>)</span> 56<span class=o>(</span>84<span class=o>)</span> bytes of data.64 bytes from 10.0.0.4: <span class=nv>icmp_seq</span><span class=o>=</span><span class=m>1</span> <span class=nv>ttl</span><span class=o>=</span><span class=m>64</span> <span class=nv>time</span><span class=o>=</span>1.06 ms64 bytes from 10.0.0.4: <span class=nv>icmp_seq</span><span class=o>=</span><span class=m>2</span> <span class=nv>ttl</span><span class=o>=</span><span class=m>64</span> <span class=nv>time</span><span class=o>=</span>1.07 ms64 bytes from 10.0.0.4: <span class=nv>icmp_seq</span><span class=o>=</span><span class=m>3</span> <span class=nv>ttl</span><span class=o>=</span><span class=m>64</span> <span class=nv>time</span><span class=o>=</span>1.03 ms64 bytes from 10.0.0.4: <span class=nv>icmp_seq</span><span class=o>=</span><span class=m>4</span> <span class=nv>ttl</span><span class=o>=</span><span class=m>64</span> <span class=nv>time</span><span class=o>=</span>1.26 ms^C 
</span></span><span class=line><span class=cl> root@396c8b142a85:/#                                         
</span></span></code></pre></div><p>还可以在容器内部跟踪ping命令的路由信息。路由信息只有一跳，证明容器间通信确实通过覆盖网络直连——无须关心底层网络，这太省心了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ root@396c8b142a85:/# traceroute 10.0.0.4traceroute to 10.0.0.4 <span class=o>(</span>10.0.0.4<span class=o>)</span>, <span class=m>30</span> hops max, <span class=m>60</span> byte packets1 test-svc.2.97v...a5.uber-net <span class=o>(</span>10.0.0.4<span class=o>)</span> 1.110ms 1.034ms 1.073ms
</span></span></code></pre></div><p>到目前为止，已经通过单条命令创建了覆盖网络，并向该网络中接入了容器。这些容器分布在两个不同的主机上，两台主机分属于不同的二层网络。在找出两台容器的IP之后，验证了容器可以通过覆盖网络完成直连。</p><h3 class="relative group">VXLAN<div id=vxlan class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#vxlan aria-label=锚点>#</a></span></h3><h4 class="relative group">Vxaln介绍<div id=vxaln介绍 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#vxaln%e4%bb%8b%e7%bb%8d aria-label=锚点>#</a></span></h4><p>Docker使用VXLAN隧道技术创建了虚拟二层覆盖网络</p><p>在VXLAN的设计中，<strong>允许用户基于已经存在的物理三层网络结构创建逻辑虚拟的二层网络</strong>。在前面的示例中创建了一个子网掩码为10.0.0.0/24的二层网络，该网络是基于一个三层IP网络实现的，三层IP网络由172.31.1.0/24和192.168.1.0/24这两个二层网络构成。具体如图所示</p><img src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072321285.png alt=image.png style=zoom:67%><p>VXLAN的美妙之处在于它是<strong>一种封装技术</strong>，能使现存的路由器和网络架构看起来就像普通的IP/UDP包一样，并且处理起来毫无问题。</p><p>为了创建二层覆盖网络，VXLAN基于现有的三层IP网络创建了隧道。基础网络（Underlay Network）这个术语，它用于指代三层之下的基础部分</p><p>VXLAN隧道两端都是VXLAN隧道终端（VXLAN Tunnel Endpoint, VTEP）。VTEP完成了封装和解压的步骤，以及一些功能实现所必需的操作，如图所示。</p><img src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072323155.png alt=image.png><h4 class="relative group">Vxlan在多主机容器通信的应用<div id=vxlan在多主机容器通信的应用 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#vxlan%e5%9c%a8%e5%a4%9a%e4%b8%bb%e6%9c%ba%e5%ae%b9%e5%99%a8%e9%80%9a%e4%bf%a1%e7%9a%84%e5%ba%94%e7%94%a8 aria-label=锚点>#</a></span></h4><p>通过IP网络将两台主机连接起来。每个主机运行了一个容器，之后又为容器连接创建了一个VXLAN覆盖网络。</p><p>为了实现上述场景，在每台主机上都新建了一个Sandbox（网络命名空间）。正如前文所讲，Sandbox就像一个容器，但其中运行的不是应用，而是当前主机上独立的网络栈。</p><p>在Sandbox内部创建了一个名为Br0 的虚拟交换机（又称做虚拟网桥），每个容器都会有自己的虚拟以太网（veth）适配器，并接入本地Br0 虚拟交换机</p><p>同时Sandbox内部还创建了一个VTEP，其中一端接入到名为Br0 的虚拟交换机当中，另一端接入主机网络栈（VTEP）。</p><p>在主机网络栈中的终端从主机所连接的基础网络中获取到IP地址，并以UDP Socket的方式绑定到4789端口。</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image.png src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072328257.png></figure><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl><span class=gh># 相关名词
</span></span></span><span class=line><span class=cl><span class=gh></span><span class=k>1.</span> Veth（Virtual Ethernet）是一种虚拟网络设备，通常用于在虚拟机或容器中创建虚拟的网络接口
</span></span><span class=line><span class=cl><span class=k>2.</span> VTEP（VXLAN Tunnel Endpoints） 是一种网络设备，用于在 VXLAN（Virtual Extensible Local Area Network）网络架构中创建和管理隧道。VXLAN 是一种网络虚拟化技术，通过封装以太网帧在 UDP 包中，允许跨越广域网（WAN）的网络流量传输。
</span></span><span class=line><span class=cl><span class=k>3.</span> VXLAN（Virtual Extensible Local Area Network，虚拟可扩展局域网）是一种网络虚拟化技术，它允许在物理网络之上创建多个虚拟网络。VXLAN：工作在网络层之上（OSI 模型的第三层或第四层）。VXLAN 通过在以太网帧外封装一个 UDP 包来实现网络虚拟化
</span></span></code></pre></div><h4 class="relative group">容器通信过程<div id=容器通信过程 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e5%ae%b9%e5%99%a8%e9%80%9a%e4%bf%a1%e8%bf%87%e7%a8%8b aria-label=锚点>#</a></span></h4><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image-20241207233030602 src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072330755.png></figure><p>将node1上的容器称为C1 ，node2上的容器称为C2 ，如下图所示。假设C1 希望ping通C2</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl><span class=gh># 发送过程
</span></span></span><span class=line><span class=cl><span class=gh></span>(1)C1 发起ping请求，目标IP为C2 的地址10.0.0.4 。
</span></span><span class=line><span class=cl>(2)该请求的流量通过连接到Br0 虚拟交换机的veth接口发出。
</span></span><span class=line><span class=cl>(3)虚拟交换机并不知道将包发送到哪里，因为在虚拟交换机的MAC地址映射表（ARP映射表）中并没有与当前目的IP对应的MAC地址。所以虚拟交换机会将该包发送到其上的全部端口。
</span></span><span class=line><span class=cl>(4)连接到Br0 的VTEP接口知道如何转发这个数据帧，所以会将自己的MAC地址返回。这就是一个代理ARP响应，并且虚拟交换机Br0 根据返回结果学会了如何转发该包。
</span></span><span class=line><span class=cl>(5)接下来虚拟交换机会更新自己的ARP映射表，将10.0.0.4映射到本地VTEP的MAC地址上。
</span></span><span class=line><span class=cl>(6)现在Br0 交换机已经学会如何转发目标为C2 的流量，接下来所有发送到C2 的包都会被直接转发到VTEP接口。
</span></span><span class=line><span class=cl>(7)VTEP接口知道C2，是因为所有新启动的容器都会将自己的网络详情采用网络内置Gossip协议发送给相同Swarm集群内的其他节点。
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl><span class=gh># 接收过程
</span></span></span><span class=line><span class=cl><span class=gh></span>(1)交换机会将包转发到VTEP接口，VTEP完成数据帧的封装，这样就能在底层网络传输。具体来说，封装操作就是把VXLAN Header信息添加以太帧当中。
</span></span><span class=line><span class=cl>(2)VXLAN Header信息包含了VXLAN网络ID（VNID），其作用是记录VLAN到VXLAN的映射关系。每个VLAN都对应一个VNID，以便包可以在解析后被转发到正确的VLAN。
</span></span><span class=line><span class=cl>(3)封装的时候会将数据帧放到UDP包中，并设置UDP的目的IP字段为node2节点的VTEP的IP地址，同时设置UDP Socket端口为4789。这种封装方式保证了底层网络之间是透明的，也可以完成数据传输。
</span></span><span class=line><span class=cl>(4)当包到达node2之后，内核发现目的端口为UDP端口4789，同时还知道存在VTEP接口绑定到该Socket。所以内核将包发给VTEP，由VTEP读取VNID，解压包信息，并根据VNID发送到本地名为Br0 的连接到VLAN的交换机。在该交换机上，包被发送给容器C2
</span></span></code></pre></div><h4 class="relative group">覆盖网络实现三层路由<div id=覆盖网络实现三层路由 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#%e8%a6%86%e7%9b%96%e7%bd%91%e7%bb%9c%e5%ae%9e%e7%8e%b0%e4%b8%89%e5%b1%82%e8%b7%af%e7%94%b1 aria-label=锚点>#</a></span></h4><p>Docker支持使用同样的覆盖网络实现三层路由。例如，读者可以创建包含两个子网的覆盖网络，Docker会负责子网间的路由。创建的命令如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker network create --subnet<span class=o>=</span>10.1.1.0/24 --subnet<span class=o>=</span>11.1.1.0/24 -d overlayprod-net  
</span></span><span class=line><span class=cl>该命令会在Sandbox中创建两个虚拟交换机，默认支持路由。
</span></span></code></pre></div><h2 class="relative group">6. Macvlan<div id=6-macvlan class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none"><a class="text-primary-300 dark:text-neutral-700 !no-underline" href=#6-macvlan aria-label=锚点>#</a></span></h2><p>能够将容器化应用连接到外部系统以及物理网络的能力是非常必要的。常见的例子是部分容器化的应用——应用中已容器化的部分需要与那些运行在物理网络和VLAN上的未容器化部分进行通信。</p><p>Docker内置的Macvlan 驱动（Windows上是Transparent ）就是为此场景而生。通过为容器提供MAC和IP地址，让容器在物理网络上成为“一等公民”</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image.png src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072241749.png></figure><p>Macvlan的优点是性能优异，因为无须端口映射或者额外桥接，可以直接通过主机接口（或者子接口）访问容器接口。但是，<strong>Macvlan的缺点是需要将主机网卡（NIC）设置为混杂模式（Promiscuous Mode） ，这在大部分公有云平台上是不允许的</strong>。所以Macvlan对于公司内部的数据中心网络来说很棒（假设公司网络组能接受NIC设置为混杂模式），但是Macvlan在公有云上并不可行</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl>正常模式：在正常模式下，网络接口卡只接收目的地是它自身 MAC 地址的数据包，以及广播和多播的数据包。
</span></span><span class=line><span class=cl>混杂模式：当网络接口卡被设置为混杂模式时，它会接收所有经过的网络流量，包括那些不发送给它的数据包。这意味着NIC能够看到在同一网络段上的所有数据包，而不仅仅是专门发给它的
</span></span></code></pre></div><p><strong>举例：</strong></p><p>假设、有一个物理网络，其上配置了两个VLAN——VLAN 100：10.0.0.0/24和VLAN 200：192.168.3.0/24，如图</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image.png src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072247308.png></figure><p>添加一个Docker主机并连接到该网络</p><p>有一个需求是将容器接入VLAN 100。为了实现该需求，首先使用Macvlan 驱动创建新的Docker网络。Macvlan 驱动在连接到目标网络前，需要设置几个参数。比如以下几点:子网信息、网关、可分配给容器的IP、主机使用的接口或者子接口</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image.png src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072248620.png></figure><p>下面的命令会创建一个名为macvlan100 的Macvlan网络，该网络会连接到VLAN 100</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ docker network create -d macvlan <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>--subnet<span class=o>=</span>10.0.0.0/24 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>--ip-range<span class=o>=</span>10.0.00/25 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>--gateway<span class=o>=</span>10.0.0.1 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>-o <span class=nv>parent</span><span class=o>=</span>eth0.100 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>macvlan100
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>--ip-range<span class=o>=</span>10.0.0.0/25:
</span></span><span class=line><span class=cl>这个参数用于限制容器可以获得的 IP 地址范围。在这个例子中，IP 地址范围是 10.0.0.0 到 10.0.0.127，提供 <span class=m>128</span> 个地址供容器使用。这样可以控制容器的 IP 地址分配。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>-o <span class=nv>parent</span><span class=o>=</span>eth0.100:
</span></span><span class=line><span class=cl>-o 是指定网络选项的参数。parent<span class=o>=</span>eth0.100 指定了宿主机上使用的网络接口。这里 eth0.100 是一个子接口（通常在 VLAN 配置中使用），表示该 Macvlan 网络将基于这个接口进行数据传输。
</span></span></code></pre></div><p>该命令会创建macvlan100 网络以及eth0.100 子接口。当前配置如图</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image.png src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072250547.png></figure><p><em>Macvlan采用标准Linux子接口，读者需要为其打上目标VLAN网络对应的ID。在本例中目标网络是VLAN 100，所以将子接口标记为 .100 （etho.100 ）</em></p><p>macvlan100 网络已为容器准备就绪，执行以下命令将容器部署到该网络中</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ docker container run -d --name mactainer1 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>--network macvlan100 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>alpine sleep 1d
</span></span></code></pre></div><p>当前配置如图11.17所示。但是切记，下层网络（VLAN 100 ）对Macvlan的魔法毫不知情，只能看到容器的MAC和IP地址。在该基础之上，mactainer1 容器可以ping通任何加入VLAN 100的系统，并进行通信</p><p><em><strong>如果上述命令不能执行，可能是因为主机</strong>NIC不支持混杂模式。切记公有云平台不允许混杂模式</em>。</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image.png src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072252416.png></figure><p>目前已经拥有了Macvlan网络，并有一台容器通过Macvlan接入了现有的VLAN当中。但是，这并不是结束。Docker Macvlan驱动基于稳定可靠的同名Linux内核驱动构建而成。因此，Macvlan也支持VLAN的Trunk功能。这意味着可以在相同的Docker主机上创建多个Macvlan网络，并且将容器按照图的方式连接起来</p><figure><img class="my-0 rounded-md" loading=lazy decoding=async fetchpriority=low alt=image.png src=https://imagebed99.oss-cn-beijing.aliyuncs.com/typora_image/202412072253602.png></figure></div><div class="flex author"><img class="!mt-0 !mb-0 h-24 w-24 rounded-full me-4" width=96 height=96 alt="Wenzhuo Huang" src=/img/header_hu_5e25c87d0dd809af.png data-zoom-src=/img/header_hu_c9326ebbd1698fbe.png><div class=place-self-center><div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">作者</div><div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">Wenzhuo Huang</div><div class="text-sm text-neutral-700 dark:text-neutral-400">幽默模块加载中&mldr;加载失败，请重新启动</div><div class="text-2xl sm:text-lg"><div class="flex flex-wrap text-neutral-400 dark:text-neutral-500"><a class="px-1 hover:text-primary-700 dark:hover:text-primary-400" href=17691281867@163.com target=_blank aria-label=Email title=Email rel="me noopener noreferrer"><span class="inline-block align-text-bottom"><span class="relative block icon"><svg viewBox="0 0 512 512"><path fill="currentColor" d="M207.8 20.73c-93.45 18.32-168.7 93.66-187 187.1-27.64 140.9 68.65 266.2 199.1 285.1 19.01 2.888 36.17-12.26 36.17-31.49l1e-4-.6631c0-15.74-11.44-28.88-26.84-31.24-84.35-12.98-149.2-86.13-149.2-174.2.0-102.9 88.61-185.5 193.4-175.4 91.54 8.869 158.6 91.25 158.6 183.2v16.16c0 22.09-17.94 40.05-40 40.05s-40.01-17.96-40.01-40.05v-120.1c0-8.847-7.161-16.02-16.01-16.02l-31.98.0036c-7.299.0-13.2 4.992-15.12 11.68-24.85-12.15-54.24-16.38-86.06-5.106-38.75 13.73-68.12 48.91-73.72 89.64-9.483 69.01 43.81 128 110.9 128 26.44.0 50.43-9.544 69.59-24.88 24 31.3 65.23 48.69 109.4 37.49C465.2 369.3 496 324.1 495.1 277.2V256.3c0-149.2-133.9-265.632-287.3-235.57zM239.1 304.3c-26.47.0-48-21.56-48-48.05s21.53-48.05 48-48.05 48 21.56 48 48.05-20.6 48.05-48 48.05z"/></svg></span></span></a></div></div></div></div><div class=mb-10></div><h2 class="mt-8 text-2xl font-extrabold mb-10">相关文章</h2><section class="w-full grid gap-4 sm:grid-cols-2 md:grid-cols-3"><article class="relative min-h-full min-w-full overflow-hidden rounded border border-2 border-neutral-200 shadow-2xl dark:border-neutral-700"><div class="flex-none relative overflow-hidden thumbnail_card_related"><img src=/docs/docker/docker%E5%AD%98%E5%82%A8%E5%8F%8A%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/featured_hu_61788c7df39d13c3.jpg alt=Docker存储及镜像制作 loading=lazy decoding=async fetchpriority=low class="not-prose absolute inset-0 w-full h-full object-cover"></div><div class="px-6 py-4"><header><a href=/docs/docker/docker%E5%AD%98%E5%82%A8%E5%8F%8A%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/ class="not-prose before:absolute before:inset-0 decoration-primary-500 dark:text-neutral text-xl font-bold text-neutral-800 hover:underline hover:underline-offset-2"><h2>Docker存储及镜像制作</h2></a></header><div class="text-sm text-neutral-500 dark:text-neutral-400"><div class="flex flex-row flex-wrap items-center"><time datetime=2025-12-03T22:26:23+08:00>2025-12-03 22:26</time><span class="px-2 text-primary-500">&#183;</span><span>1286 字</span><span class="px-2 text-primary-500">&#183;</span><span title=预计阅读>7 分钟</span></div></div><div class="prose dark:prose-invert py-1"></div></div><div class="px-6 pt-4 pb-2"></div></article><article class="relative min-h-full min-w-full overflow-hidden rounded border border-2 border-neutral-200 shadow-2xl dark:border-neutral-700"><div class="flex-none relative overflow-hidden thumbnail_card_related"><img src=/docs/docker/docker%E7%AE%80%E4%BB%8B/featured_hu_61788c7df39d13c3.jpg alt=Docker简介 loading=lazy decoding=async fetchpriority=low class="not-prose absolute inset-0 w-full h-full object-cover"></div><div class="px-6 py-4"><header><a href=/docs/docker/docker%E7%AE%80%E4%BB%8B/ class="not-prose before:absolute before:inset-0 decoration-primary-500 dark:text-neutral text-xl font-bold text-neutral-800 hover:underline hover:underline-offset-2"><h2>Docker简介</h2></a></header><div class="text-sm text-neutral-500 dark:text-neutral-400"><div class="flex flex-row flex-wrap items-center"><time datetime=2025-12-03T22:26:23+08:00>2025-12-03 22:26</time><span class="px-2 text-primary-500">&#183;</span><span>376 字</span><span class="px-2 text-primary-500">&#183;</span><span title=预计阅读>2 分钟</span></div></div><div class="prose dark:prose-invert py-1"></div></div><div class="px-6 pt-4 pb-2"></div></article></section></div><script type=text/javascript src=/js/page.min.54b6f4371722649edbe871e431d8670d670878c22be8f36e229fe53cc9b786fe25a834def5e6de621f7a3e37b72bc8cd73839aa5ed907ed6cbd45cd3e1b0fa20.js integrity="sha512-VLb0NxciZJ7b6HHkMdhnDWcIeMIr6PNuIp/lPMm3hv4lqDTe9ebeYh96Pje3K8jNc4Oape2QftbL1FzT4bD6IA==" data-oid=views_docs/docker/docker基本使用/index.md data-oid-likes=likes_docs/docker/docker基本使用/index.md></script></section><footer class="pt-8 max-w-prose print:hidden"><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span class="flex flex-col"><a class="flex text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" href=/docs/docker/docker%E7%AE%80%E4%BB%8B/><span class=leading-6><span class="inline-block rtl:rotate-180">&larr;</span>&ensp;Docker简介
</span></a><span class="ms-6 mt-1 text-xs text-neutral-500 dark:text-neutral-400"><time datetime=2025-12-03T22:26:23+08:00>2025-12-03 22:26</time>
</span></span><span class="flex flex-col items-end"><a class="flex text-right text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" href=/docs/docker/docker%E5%AD%98%E5%82%A8%E5%8F%8A%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/><span class=leading-6>Docker存储及镜像制作&ensp;<span class="inline-block rtl:rotate-180">&rarr;</span>
</span></a><span class="me-6 mt-1 text-xs text-neutral-500 dark:text-neutral-400"><time datetime=2025-12-03T22:26:23+08:00>2025-12-03 22:26</time></span></span></div></div></footer></article><div id=scroll-to-top class="fixed bottom-6 end-6 z-50 transform translate-y-4 opacity-0 duration-200"><a href=#the-top class="pointer-events-auto flex h-12 w-12 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label=返回顶部 title=返回顶部>&uarr;</a></div></main><footer id=site-footer class="py-10 print:hidden"><nav class="flex flex-row pb-4 text-base font-medium text-neutral-500 dark:text-neutral-400"><ul class="flex list-none flex-col sm:flex-row"><li class="flex mb-1 text-end sm:mb-0 sm:me-7 sm:last:me-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2 flex items-center" href=/posts/authors/ title=Authors>作者</a></li><li class="flex mb-1 text-end sm:mb-0 sm:me-7 sm:last:me-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2 flex items-center" href=/tags/ title=Tags>标签</a></li><li class="flex mb-1 text-end sm:mb-0 sm:me-7 sm:last:me-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2 flex items-center" href=/categories/ title=Categories>分类</a></li></ul></nav><div class="flex items-center justify-between"><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2025
Wenzhuo Huang</p><p class="text-xs text-neutral-500 dark:text-neutral-400">由 <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://blowfish.page/ target=_blank rel="noopener noreferrer">Blowfish</a> 强力驱动</p></div><script>mediumZoom(document.querySelectorAll("img:not(.nozoom)"),{margin:24,background:"rgba(0,0,0,0.5)",scrollOffset:0})</script><script type=text/javascript src=/js/process.min.ee03488f19c93c2efb199e2e3014ea5f3cb2ce7d45154adb3399a158cac27ca52831db249ede5bb602700ef87eb02434139de0858af1818ab0fb4182472204a4.js integrity="sha512-7gNIjxnJPC77GZ4uMBTqXzyyzn1FFUrbM5mhWMrCfKUoMdsknt5btgJwDvh+sCQ0E53ghYrxgYqw+0GCRyIEpA=="></script></footer><div id=search-wrapper class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh] z-500" data-url=https://your_domain.com/><div id=search-modal class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex items-center justify-between flex-none px-2"><form class="flex items-center flex-auto min-w-0"><div class="flex items-center justify-center w-8 h-8 text-neutral-400"><span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder=搜索 tabindex=0></form><button id=close-search-button class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title="关闭 (Esc)">
<span class="relative block icon"><svg viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto px-2 overflow-auto"><ul id=search-results></ul></section></div></div></div></body></html>